<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Roblox UGC Editor</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #f6f7fb;
        touch-action: none;
      }
      #root {
        position: relative;
        width: 100%;
        height: 100%;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
      const state = {
        brush: {
          color: "#7c3aed",
          size: 24,
          opacity: 1.0,
        },
        layer: "albedo",
        canvasSize: 1024,
        ready: false,
      };

      const layers = {
        albedo: { canvas: null, ctx: null, texture: null },
        metalness: { canvas: null, ctx: null, texture: null },
        roughness: { canvas: null, ctx: null, texture: null },
        normal: { canvas: null, ctx: null, texture: null },
      };

      let renderer;
      let scene;
      let camera;
      let controls;
      let meshRoot;
      let raycaster;
      let pointer = new THREE.Vector2();

      function postMessage(type, payload) {
        if (window.EditorBridge && window.EditorBridge.postMessage) {
          window.EditorBridge.postMessage(
            JSON.stringify({ type, payload: payload || {} })
          );
        }
      }

      function createLayerCanvas(name, fillStyle) {
        const canvas = document.createElement("canvas");
        canvas.width = state.canvasSize;
        canvas.height = state.canvasSize;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = fillStyle;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.flipY = false;
        layers[name] = { canvas, ctx, texture };
      }

      function initLayers() {
        createLayerCanvas("albedo", "#cfcfd6");
        createLayerCanvas("metalness", "#000000");
        createLayerCanvas("roughness", "#ffffff");
        createLayerCanvas("normal", "#8080ff");
      }

      function initScene() {
        const root = document.getElementById("root");
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(root.clientWidth, root.clientHeight, false);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        root.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        scene.background = new THREE.Color("#f6f7fb");

        camera = new THREE.PerspectiveCamera(
          45,
          root.clientWidth / root.clientHeight,
          0.1,
          100
        );
        camera.position.set(0, 1.6, 3.2);

        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
        scene.add(hemi);
        const dir = new THREE.DirectionalLight(0xffffff, 0.9);
        dir.position.set(3, 6, 4);
        scene.add(dir);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enablePan = false;
        controls.minDistance = 1.5;
        controls.maxDistance = 6;

        raycaster = new THREE.Raycaster();

        window.addEventListener("resize", onResize);
        renderer.domElement.addEventListener("pointerdown", onPointerDown);
        renderer.domElement.addEventListener("pointermove", onPointerMove);
        renderer.domElement.addEventListener("pointerup", onPointerUp);
        renderer.domElement.addEventListener("pointerleave", onPointerUp);

        animate();
      }

      function onResize() {
        if (!renderer || !camera) return;
        const root = document.getElementById("root");
        const w = root.clientWidth;
        const h = root.clientHeight;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }

      let painting = false;

      function getPointerCoords(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      }

      function onPointerDown(event) {
        painting = true;
        paintAtEvent(event);
      }

      function onPointerMove(event) {
        if (!painting) return;
        paintAtEvent(event);
      }

      function onPointerUp() {
        painting = false;
      }

      function paintAtEvent(event) {
        if (!meshRoot) return;
        getPointerCoords(event);
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObject(meshRoot, true);
        if (!intersects.length) return;
        const hit = intersects[0];
        if (!hit.uv) return;
        paintAtUV(hit.uv);
      }

      function paintAtUV(uv) {
        const layer = layers[state.layer];
        if (!layer || !layer.ctx) return;
        const x = uv.x * state.canvasSize;
        const y = (1 - uv.y) * state.canvasSize;
        const ctx = layer.ctx;
        ctx.save();
        ctx.globalAlpha = state.brush.opacity;
        const radius = state.brush.size;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);

        const color = resolveBrushColor(state.layer, state.brush.color);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.restore();
        layer.texture.needsUpdate = true;
      }

      function resolveBrushColor(layerName, color) {
        if (layerName === "metalness" || layerName === "roughness") {
          const rgb = hexToRgb(color);
          const luma = Math.round(
            0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b
          );
          return `rgb(${luma},${luma},${luma})`;
        }
        if (layerName === "normal") {
          return "#8080ff";
        }
        return color;
      }

      function hexToRgb(hex) {
        const safe = hex.replace("#", "");
        const bigint = parseInt(safe, 16);
        return {
          r: (bigint >> 16) & 255,
          g: (bigint >> 8) & 255,
          b: bigint & 255,
        };
      }

      function applyMaterial(mesh) {
        const material = new THREE.MeshStandardMaterial({
          map: layers.albedo.texture,
          metalnessMap: layers.metalness.texture,
          roughnessMap: layers.roughness.texture,
          normalMap: layers.normal.texture,
          metalness: 1.0,
          roughness: 1.0,
        });
        mesh.material = material;
        mesh.material.needsUpdate = true;
      }

      function loadModel(url) {
        if (!url) {
          createFallbackModel();
          return;
        }

        const loader = new THREE.GLTFLoader();
        loader.load(
          url,
          (gltf) => {
            if (meshRoot) {
              scene.remove(meshRoot);
            }
            meshRoot = gltf.scene;
            meshRoot.traverse((child) => {
              if (child.isMesh) {
                applyMaterial(child);
              }
            });
            scene.add(meshRoot);
            postMessage("modelLoaded", { url });
          },
          undefined,
          () => {
            createFallbackModel();
          }
        );
      }

      function createFallbackModel() {
        if (meshRoot) {
          scene.remove(meshRoot);
        }
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const mesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial());
        applyMaterial(mesh);
        meshRoot = new THREE.Group();
        meshRoot.add(mesh);
        scene.add(meshRoot);
        postMessage("modelLoaded", { url: "fallback" });
      }

      function setBrush(brush) {
        if (brush.color) state.brush.color = brush.color;
        if (typeof brush.size === "number") state.brush.size = brush.size;
        if (typeof brush.opacity === "number")
          state.brush.opacity = brush.opacity;
      }

      function setLayer(name) {
        if (layers[name]) {
          state.layer = name;
        }
      }

      function setTextureUrls(textures) {
        const entries = [
          { key: "albedo", url: textures.albedo },
          { key: "metalness", url: textures.metalness },
          { key: "roughness", url: textures.roughness },
          { key: "normal", url: textures.normal },
        ];
        entries.forEach((entry) => {
          if (!entry.url) return;
          const image = new Image();
          image.crossOrigin = "anonymous";
          image.onload = () => {
            const layer = layers[entry.key];
            if (!layer || !layer.ctx) return;
            layer.ctx.clearRect(0, 0, state.canvasSize, state.canvasSize);
            layer.ctx.drawImage(image, 0, 0, state.canvasSize, state.canvasSize);
            layer.texture.needsUpdate = true;
          };
          image.src = entry.url;
        });
      }

      function exportTextures() {
        const payload = {
          albedo: layers.albedo.canvas.toDataURL("image/png"),
          metalness: layers.metalness.canvas.toDataURL("image/png"),
          roughness: layers.roughness.canvas.toDataURL("image/png"),
          normal: layers.normal.canvas.toDataURL("image/png"),
        };
        postMessage("export", payload);
      }

      function animate() {
        requestAnimationFrame(animate);
        if (controls) controls.update();
        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
      }

      function init() {
        initLayers();
        initScene();
        createFallbackModel();
        state.ready = true;
        postMessage("ready", {});
      }

      window.editor = {
        init,
        loadModel,
        setBrush,
        setLayer,
        setTextureUrls,
        exportTextures,
      };

      init();
    </script>
  </body>
</html>
